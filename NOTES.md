# Regular expression

通过使用正则表达式，可以：

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。

例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。











# Law

最终解释权相关规定一般出现在合同的格式条款中，格式条款是当事人为了重复使用而预先拟定，并在订立合同时未与对方协商的条款。采用格式条款订立合同的，提供格式条款的一方应当遵循公平原则确定当事人之间的权利和义务，并采取合理的方式提示对方注意免除或者减轻其责任等与对方有重大利害关系的条款，按照对方的要求，对该条款予以说明。提供格式条款的一方未履行提示或者说明义务，致使对方没有注意或者理解与其有重大利害关系的条款的，对方可以主张该条款不成为合同的内容。有下列情形之一的，该格式条款无效：

　　（一）具有本法第一编第六章第三节和本法第五百零六条规定的无效情形；

　　（二）提供格式条款一方不合理地免除或者减轻其责任、加重对方责任、限制对方主要权利；

（三）提供格式条款一方排除对方主要权利。

# 物理实验：

1。有效数字  加减取最高 乘除取最低4舍6入5抽偶；五"指的是根据5后面的数字来定，当5后有数时，舍5入		1;当5后无有效数字时，需要分两种情况来讲:①5前为奇数，舍5入1;②5前为偶数，舍5不进。
		   
统计学相关：测量方法：最小二乘法（假设实际y：Σ（y1-y)^2;多变量偏导拟合；相关系数r与线性关系的拟合0.999)与正态分布3δ
					  逐差法（高中处理纸带）
					

APA style: 

Bordo(2001)noted/claimed.... 

# 面向对象语言(OO)知识点：

## 三个特征

- **封装**
  封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
- **继承**
  继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。通过继承创建的新类称为「子类」或「派生类」，被继承的类称为「基类」、「父类」或「超类」。
  要实现继承，可以通过 **继承和组合** 来实现。
- **多态性**
  多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单说就是一句话：允许将子类类型的指针赋值给父类类型的指针。
  实现多态，有两种方式，覆盖和重载。两者的区别在于：**覆盖在运行时决定**，**重载是在编译时决定**。**并且覆盖和重载的机制不同**。例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。



我对面向对象的理解：**面向对象的编程方式使得每一个类都只做一件事**。**面向过程会让一个类越来越全能，就像一个管家一样做了所有的事**。而面向对象像是雇佣了一群职员，每个人做一件小事，各司其职，最终合作共赢

## 1.类之间的关系：

​	 				简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。				

​				is-a关系也叫继承inheritance或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。

​				has-a关系通常称之为聚类（关联）aggregation,比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。
​				use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。

## 2创建对象 

  Vehicle veh1;veh1 = new Vehicle();==等价 Vehicle veh1 = new Vehicle();事实上应该是 veh1 是包含 Vehicle 对象的一个引用。
				

		数据存储：auto普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ,
				static静态数据,地址不变 只初始化一次 静态局部变量存值如同全局变量, 区别在于它只属于拥有它的函数; 它也会被初始化为空，
				extern外部变量声明不产生新数据,register  CPU加快 用于频繁使用的变量;
# PYTHON:

1.和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是**使用了缩进的方式来表示代码的层次结构**

def roll_dice(n=2): for _ in range(1,100):  使用：代替{   }

![复合赋值位运算符“＆=、^ =、| =”](https://exp-picture.cdn.bcebos.com/23fd63c5cf672b5fa55afa223314f4d0b40327b1.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

# UML统一建模语言

是一种为[面向对象](https://baike.baidu.com/item/面向对象/2262089)系统的产品进行说明、可视化和[编制](https://baike.baidu.com/item/编制/9907954)文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。

windows中只有“/r/n”才能正确触发“我们理解的换行”操作

## 回车、换行的区别

在Windows中：

‘\r’ (回车)：即将光标回到当前行的行首(而不会换到下一行)，之后的输出会把之前的输出覆盖

‘\n’ 换行，换到当前位置的下一位置，而不会回到行首；

Unix系统里，每行结尾只有“<换行>”，即"\n"；

**Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；**

Mac系统里，每行结尾是“<回车>”，即"\r"；

也就是：

**Linux中遇到换行符("\n")会进行回车+换行**的操作，回车符（“\r”）反而只会作为控制字符("^M")显示，不发生回车的操作。
而windows中要回车符+换行符("\r\n")才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。
一个直接后果是：

**Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；**
**Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。**

在解析字符串，或其他格式的文件内容的时候，经常需要判定回车换行”的地方，这个时候就要注意：既要判定"\r\n"又要判定"\n"。

写程序时可能得到一行，将其进行trim掉’\r’,这样能得到所需要的string了。


## 基础数据类型

列表转换：list(str1) 　将字符串转化成列表

元组转换：tuple(list01)　　将列表转换为元组

字典转换：dict(zip(keylist,valuelist))　　列表转换成字典

集合转换：set(list01)　　列表转换为集合

### 	2.循环       

- `range(1, 101, 2)`：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。
- `range(100, 0, -2)`：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。





# JAVA基础:

jdk包含jre包含jvm；JRE是java运行时的环境，包含jvm和核心类库，JDK是开发工具包
					
springboot: 1、Application.java 建议放到根目录下面,主要用于做一些框架配置
			2、model 目录主要用于实体与数据访问层（Repository）
			3、service 层主要是业务类代码
			4、controller 负责页面访问控制
			常用概念：		 Html+CSS+JS，都是在浏览器端执行，统一称之为前端。后端专注业务逻辑
而Java，C，Python，PHP这些可以运行在服务器端的，统一称之为后端。Ajax就是只传递数据，不传递整个网页。这也是被用来在翻页，注册，发送验证码等场景，但也仅仅止布于此了。
python:
						把相对独立且经常重复使用的代码放置到函数中

							Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从small_ints中获取引用而不是临时创建新的对象。因为大于256或小于-5的整数不在该范围之内，所以就算两个整数的值是一样，但它们是不同的对象。
							. and()用法区别
							　　注意：
	
							　　在交互模式（>>>的符号，命令行模式）下，return的结果会自动打印出来，而作为脚本单独运行时则需要print函数才能显示。
								   return还有一个重要特性：在函数中，凡是遇到return，这个函数就会结束。

# C程序语言设计：

## 结构体

C语言--“.”与“->”有什么区别？：都是访问结构体的方式， ->指向结构体的指针,equals (*a).b；

## 循环

1）break语句通常用在循环语句和开关语句中。当break用于开关语句switch中时，可使程序跳出switch而执行switch以后的语句；如果没有break语句，则将成为一个死循环而无法退出。
当break语句用于do-while、for、while循环语句中时，可使程序终止循环而执行循环后面的语句，通常break语句总是与if语句联在一起，即满足条件时便跳出循环。

2）continue语句的作用是跳过循环体中剩余的语句而强行执行下一次循环。continue语句只用在for、while、do-while等循环体中，常与if条件语句一起使用，用来加速循环

## 基础

#include.. .h文件是头文件，内含函数声明、宏定义、结构体定义等内容
　　                   	          .c文件是程序文件，内含函数实现，变量定义等内容。
			强制类型转换 (type_name)variable	整数除法 31/44 = 0 但 (float)31/44 = 0.7123
					库函数：{	math.h    1.ploy()功能：求以向量为解的方程或方阵的特征多项式。
					cmath.h   fabs( )主要是求精度要求更高的double ，float 型的绝对值



​	String.h: **void \*memset(void \*s, int c, size_t n);** 

##### **memset**:初始化字符串

memset函数按字节对内存块进行初始化，所**以不能用它将int数组初始化为0和-1之外的其他值**（除非该值高字节和低字节相同）。

作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。					}

```
#include <memory.h>
 
int main(void)
{
    char buffer[]="Helloworld\n";
    printf("Buffer before memset:%s\n",buffer);
    memset(buffer+2,'*',sizeof(buffer));
    printf("Buffer after memset:%s\n",buffer);
    return 0;
}
输出结果：

Buffer before memset:Helloworld
 
Buffer after memset:He*********
```

​		printf("%s/n",a%2==0 ? "even":"odd");(条件? 满足:不满足)结构

​		int 把main（）的值返回给os  ；c所使用的参数都要预先规定；main必须有
​	%#o，0表示八进制；0X表示十六进制

++在变量后，意味着执行完这条语句才++		count++ 等于 count+=1 前缀++a 常用（先递增n，再使用）vs 后缀a++ 先使用a再递增

位置是逻辑上的概念，与实现无关连续用

Difference between

for(initialization;condition;update)

### scanf

while(scanf("%d,&n)&&n!=0)
while(scanf("%d",&n&&n)
while(scanf("%d",&n),n)
功能：当输入n且n!=0时继续循环，当n为0时结束循环(上述三种写法都可实现此种功能）
while(scanf("%d,&n)!=EOF)和while(~scanf("%d",&n)
功能：当读到文件结尾时终止循环

两个scanf(%c)的问题： 

1。清空输入缓冲区
	   第一个scanf后加入语句：fflush(stdin); //C语言清空输入缓冲区函数

2。格式控制中加入空格          or 第一个scanf(%c\n)
	   将第二个scanf改为：scanf(" %c",&ch2);//在%号前面加一个空格				name == &name[0]
	   用scanf读string  scanf（“%s, char);scanf("%s",string)前者速度更快，现在想了想应该是数组名可以表示数组首地址的原因。
	scanf格式输入时要求输入格式与格式控制符中的完全一样(如：scanf("abcd%c",&ch);

​	输入时必须输入abcde,ch得到的值为e)空格可以抵消前面输入的回车符。
​		所以scanf（%s）只能读一个单词 
​	scanf（"%3.2f"）错误 读float和double时不能指定精度	读到第一个空白时停止  &储存int型scanf("%d ,&price");的地址
​		

059 (0开头的表示8进制，但9错误)；0xAF	（16进制，10*16+15）         
printf("%x", x);  // 以16进制格式输出，输出17；			printf("%o", x);  // 以8进制格式输出，输出2。

“a”字符串‘a’字符常量、是以其代码（一般采用ASCII代码，整数类型）储存的；如果这样，char s[]="abc";sizeof(s)=4;
对于字符串结回尾有一个'\0'做结束符，所以它占四个直接空间。sizeof()!!!!测定
再比如 char* s = "abcde";sizeof(s) = 4;
因为s是一个指针，无论指针指向什么内容，指针本答身就是一个地址，它只占4个字节。
系统默认浮点型常量是double类型的精度，//2表示’最小‘字符宽度//float 2.3f，2.3e10F；
%f 单精度浮点数    	%e 指数形式输出	%g 浮点型数据 会去掉多余的零 至多保留6位
**sizeof测量预留空间，sizeof name sizeof（char）;strlen()测量长度**
转义字符'\123' 这个表示asc码为123的字符                            char nerf ='\n'转义字符单引号括起来；但双引号内的不用
	重定向： c1<words                       //使计算机从文件中查找输入而不是键盘
		C本身不提供输入输出语句 printf，scanf通过调用库中的函数实现，他们也不是c语言中的关键字；		

## 	函数：

​	{ 	随机数：		如果想要产生一个数是从1开始到最大值的，比如说，想要产生一个1-100之间的随机数，那么用法如下
​						int num = rand() % 100 + 1;srand函数 srand(time(0))   srand函数是随机数发生器的初始化函数，如果要确保每次产生的都不一样，我们需要引用一个专门为rand设置随机化种子的函数srand()
​				枚举类型（enum）enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };auto 赋值Mon=0 Tues=1....   赋予新的类型week 可以赋予每一个枚举值若干个属性
​	基础    即使将参数传给无返回值的void函数也能实现对原始参数值的修改
​		void函数利用（引用或者指针）来“返回”处理结果是程序员经常用到的方式，主要原因是：一可以让代码更简洁，二是能减少内存空间的占用。
​		? 传值：  定义函数时函数括号中的变量名称为形式参数，简称形参或虚拟参数；Local variable ：function scope ,block scope //for(int i)
​		形式参数parameter是被调函数的变量，实际参数是主调函数（main）赋给被调函数的具体值

​				注意

​		1、 C语言中实参和形参之间的数据传递是单向的“**值传递**”，单向传递，只能由实参传给形参，反之不能。
​		2、 被调用函数的形参只有函数被调用时才会临时分配存储单元，一旦调用结束占用的内存便会被释放。
​		3、 传值方式传递的是实参的一个拷贝。
​			传值：将实参的值传递给形参
​		? 主调函数向调用函数传递参数实际上只是将实参的拷贝（即临时副本）传递
​		给了被调用函数，并不是实参本身，这样被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时变量副本的值。
​		? 传递给调用函数的都是实参的一个拷贝，直接对拷贝进行操作不会影响实参。
​		invoke调用 ,recursive递归：(不会)  n往n-1归 f(n)=f(n-1)+f(n-2)
​								阶乘——stack栈last in first out;
​		? ?这种信息传递是单方向的，形参不能将值传回给实参。

## 	指针 (*,&运算符)

(){ 函数改变全局变量不用指针；	

1.float *ptr = &a;//定义指针变量

2. *间接运算符/解引*用 （得到指针所指向对象的值）        &地址运算符(得到指针本身的地址)
   ​			n = 22， 	* ptr = &n;//ptr指向n//            Question:*"space"== ?
   ​			val = *ptr;//把ptr指向地址的值赋予val		ar[i]等于*  *(ar+i)			*ptr++ 指针指向数组下一个元素
   ​			myfunct(&hour,&minute)				//phour指向hour的地址 传地址，用值计算，再传回地址     myfunct（x）传值
   ​			void myfunct(int *phour,int *pminute)
   ​	}
   ​	**数组 指针 函数**：

```
 ``p->num = 5; // ->指向结构体成员运算符          
```

数组指针是指向数组首元素的地址的指针，其本质为指针；指针数组是数组元素为指针的数组，其本质为数组。
​	函数对指针进行操作，指针作用域只限于函数，但改变的地址可以影响main（）//可返回多个值

2. 

   

3. 1。array as function arguments:引用传递，参数的地址相同   int sum_arr (int att【size】)   //这是错的，不能传入长度
   ​		2.char *s1="hello";//声明一个指针指向常量"hello"；char s2[]="hello";//在栈中开辟一个数组字符"hello";/** s2[]="he" 相当于* char s2[3];
   ​				* s2[0]='h';* s2[1]='e';s2[2]='\0';			一般来说，如果你不给变量一个确定的值，就直接引用它，则系统不能
   ​				保证运行的唯一性，源而这是我们程序所不允许的。所以我们一般用初始化的方法来确定其值。
   ​		3.指针与多维数组；zippo[4][2];  zippo表示二维数组首元素的地址；zippo[2][1]==*(*(zippo+2)+1)//第3个一维数组的第2个int元素//
   
   ### Static
   
   ![image-20210405131130699](C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210405131130699.png)
   
   (2)存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。
   
   ​	(3)	初始化数组,  static char str[10];默认为0
   
   ​			2、指针数组  char* name[]是一个数组指针，数组里面保存的都是指针，那么name[0]里面保存的就是指针，也就是你说的地址
   ​				例：
   ​				int a[M][N];
   ​				int *p[M];//存放指针的数组
   ​				for(int i=0; i<M; i++)
   ​				p[i] = a[i];
   ​				之后用法度可以跟二维数组一样问，缺点在于答M是固定的
   ​			3、指向数组的指针
   ​				例：																
   ​				int a[M][N];
   ​				int (*p)[N];
   ​				p = a;
   ​				用起来跟二维数组没区别，缺点在于N是固定的
   ​	4、二级指针
   ​				例：
   ​				int a[M][N];
   ​				int **p;
   ​				p = (int *)malloc(sizeof(int *)*M);
   ​				for(int i=0; i<M; i++)
   ​				{
   ​				p[i] = a[i];
   ​				}
   ​				之后的用法可以跟二维数组一样，缺点在于用法比较麻烦，需要维护动态内存

## 字符串

			* ```
	{		getchar()从键盘读取，搭配putchar('*')用于输入密码时不显示密码;int getc(FILE *stream);从文件流中读取一个内字符。
	input validation:检验输入是否符合标准；
gets()输入字符串过长可能造成缓冲区溢出，擦除内存中的其他数据；fgets(name[i], 20, stdin)is the best
空字符和空指针（NULL）是一个地址占4byte				

##### string.h

中有strlen()strcat()strcmp()strncmp(zippo[i],"sadf",4)/*检测该数组前4个是否sadf//若两个string相同返回0,若第一个字符在第二个字符ASCII前面返回-1//
	strcpy()strncpy()
	}
	```
	
	

## 文件i/o

			* ```
	{	重点：区别stdi/o的函数 区分是输出到文件流还是屏幕	fopen(, "r,w,a")文件指针是指向FILE的指针； rewind()使文件内部的指针重新回到文件开头 fseek(infile,offset,origin)：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END)）为基准，偏移offset（指针偏移量）
		ftell()返回偏移字节;fclose(ptr)   ;while(feof(stdin)||feof(ptr))； 文本文件 fscanf windows对文本文件读写的时候，会将换行 \n自动替换成 \r\n。
	fscanf(stdin)or fscanf（ptr）
	二进制文件fread fwrite 频繁地保存和访问数据．那么应该采用二进制文件进行存放可以节省存储空间和转换时间。
}
	结构{          enum               先定义类型后定义结构变量； 用.访问；   类似数组 但成员可以是不同类型           typedef struct {}PNT；简化
结构运算 可以赋值= 传值到函数    today = (struct day){2014,07,13}
	}
	```

运算符优先级 单目+- >  %*/ >;=是运算符而不是语句
		位运算{    ~取反运算符，0和1互换    按位与&
		}

## 错误

1. 都会出现错误提示: [Error] assignment to expression with array type

​	中文通俗意思：不可以赋值给具有数组类型的表达式。这里的表达式是指整个数组的首地址。

​	也就是说在C语言内部 数组的首地址是不可更改的，相当于被const修饰

### SIGSEGV Segmentation fault.段错误

1.利用指针对数组间访时越界了，即间访到该数组后面的空间了（即间访了一段不属于操作系统给你的空间。）

2.间访悬挂或   空指针!!!           

写入东西，应先用内存分配为指针分配一段空间或将其指向某个东西。

3.

![img](https:////upload-images.jianshu.io/upload_images/145616-20d409476a8c5ed8.png?imageMogr2/auto-orient/strip|imageView2/2/w/492/format/webp)



​    程序企图向指针ps所指内存中写入,但指针ps所指的是常量字符串，在生成可执行文件后它会与代码段放在一起，该区域是只读的，所以企图修改指针所指内容会出错。

**Notice**

<1>定义了指针后记得初始化，在使用的时候记得判断是否为NULL
<2>在使用数组的时候是否被初始化，数组下标是否越界，数组元素是否存在等
<3>在变量处理的时候变量的格式控制是否合理等

