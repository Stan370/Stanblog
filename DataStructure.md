# DataStructure

### 

1 基于存储空间的考虑：

 存储空间的分配**：**

顺序表： 静态分配。若线性表长度变化较大，则存储 空间难以预先确定。估计过大将造成空间浪费，估计过小又将使空间溢出机会增多。 

链表：  动态分配。只要内存空间尚有空闲，就不会 产生溢出。 因此，当线性表长度变化较大，难以估计其存储规 模时，以采用动态链表作为存储结构为宜。 存储密度**：** 顺序表100%。 链表的每个结点，除了数据域外，还要有指针域，从 存储密度来讲，这是不经济的。若数据域和指针域 所占的空间大小相同，则链表的存储密度为50%。

2 基于时间的考虑：

   顺序表是一种随机存储结构，按序号访问其 元素ai，可在O(1)时间内直接的存储。而链表中的 结点，必须从头指针起顺着链表扫描才能取得。因 此，若线性表的操作主要是进行**查找**，则以顺序表 为宜。     在链表中插入和删除操作，只要修改指针。 而在顺序表中平均要移动近一半的结点。因此，对 于频繁地进行**插入和删除**操作的线性表，宜采用链表做存储结构。

## 链表

创建链表涉及下面 3 步：

（1）使用malloc()为结构分配足够的空间；

（2）存储结构的地址；

（3）把当前信息拷贝到结构中

1. ```
   1. typedef struct Link{
   2. ​    char elem; //代表数据域
   3. ​    struct Link * next; //代表指针域，指向直接后继元素，声明一个指向Link结构的next指针
   4. }link; //link为节点名，每个节点都是一个 link 结构体
   ```

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = NULL,*cur = head;    //双指针
        while(cur!=NULL){
            ListNode *t = cur->next;
            cur->next = pre;
            pre = cur;
            cur = t;
        }
        return pre;        //why isn't return cur??
    }
};
```

👆逆置链表

**顺序查找和直接插入的哨兵作用**

```
int Sequential_Search2(int *a int n,int key)  
{  
    int i=0;  
    a[0]=key;//哨兵  
    i=n;  
    while(a[i]!=key)  
    {  
        i--;  
    }  
    return i;//返回0就是查找失败  
}  //提高查找效率
```



### 头节点

经以上删除结点代码看出，当没有头结点时，每次删除时都得去做下特殊判断，而删除带有头结点的链表时，删除的处理上更具有统一性，这也体现了链表有头结点的优点。

头指针：
  指向单链表的第一个结点的指针， 如果单链表有头结点，则头指针指向头结点 ，如果单链表没有头结点，则头指针指向第一个首元结点。
首元结点：
单链表中第一个有数据元素的结点。如果单链表有头结点，则首元结点为头结点的下一个结点，如果单链表没有头结点，则首元结点就是单链表的第一个结点。

<img src="https://img-blog.csdn.net/20140413163832421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXV6aHVseWRpYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:80%;" /><--有头节点

### 储存方式

线性表是一个抽象的概念，表里的每个元素都有唯一的前驱和唯一的后继，所以元素们排成一条线，叫“线性”表。

数组是一种具体的存储数据的方式，它可以用来实现线性表，但不是只能用来表示线性表，还可以表示树，也可以表示图。。。

### 值、地址、引用传递

void ex2(int *px,int *py){

​	//交换地址上的值

}

void main(){

​		ex2(&a,&b)

}

void ex3(int &x,int &y){

​		temp = x; x=y; y=temp;//直接用x y代替a b

}

void main(){

​		ex3(a,b)//调用方法与值传递相同

}

## 栈和队列

递归的实现利用——栈

Q1:两个栈实现一个队列

Q2：逆置链表

Q3:括弧匹配检验

```
int l=strlen(a);
12     for(int i=0;i<l;i++)
13     {
14         if(a[i]=='(')
15         {
16             stack[top]=a[i];
17             top++;
18         }
19         else if(a[i]=='[')
20         {
21             stack[top]=a[i];
22             top++;
23         }
24         else if(a[i]==')')
25         {
26             if(stack[top-1]=='(')
27             top--;
28             else 
29             {
30                 cout<<"Wrong";
31                 return 0;
32             }
33         }
34         else if(a[i]==']')
35         {
36             if(stack[top-1]=='[')
37             top--;
38             else 
39             {
40                 cout<<"Wrong";
41                 return 0;
42             }
43         }
45     }
46     if(top==1)
48         cout<<"OK";
```



### 堆（Heap）与栈（Stack）

是开发人员必须面对的两个概念，在理解这两个概念时，需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：

**（1）程序内存布局场景下，堆与栈表示两种内存管理方式；**<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210508150143938.png" alt="image-20210508150143938" style="zoom:50%;" />

**（2）数据结构场景下，堆与栈表示两种常用的数据结构。**

堆就是用数组实现的二叉树，所以它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。

当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210508150841862.png" alt="image-20210508150841862" style="zoom:67%;" />


堆的常用方法：

- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）





	//Heapsort
	// 最后一个叶子节点和根节点交换，并进行堆调整，交换次数为len-1次
	for(int i=len-1;i>0;--i) {
		//最后一个叶子节点交换
		array[i]=array[i]+array[0];
		array[0]=array[i]-array[0];
		array[i]=array[i]-array[0];
	    
	    // 堆调整
		minHeapFixDown(array, 0, len-i-1);  
	}
}

## 树和二叉树

#### Definitions

树由n个节点组成的有限集合，在非空树中（1）只有一个root节点（2）n>1,其余节点被分为m个有限集，每个集合称为子树Subtree。

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210416131651559.png" alt="image-20210416131651559" style="zoom: 33%;" />

二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别

### Binary tree

1.定义递归 		 2.  0<=节点度<=2  		 3.有序树，次序不可交换

性质 

1、第i层至多2^(i-1)个节点			2. 深度为k的二叉树至多有2^k-1个节点			

3.对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0= n2+ 1。（Proof：进入结点分支 = 离开节点分支）

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210416140046398.png" alt="image-20210416140046398" style="zoom:50%;" />

##### 完全二叉树

一棵深度为k的有n个结点的[二叉树](https://baike.baidu.com/item/二叉树/1602879)，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与[满二叉树](https://baike.baidu.com/item/满二叉树/7773283)中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

#### 树的链式存储

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210416150509922.png" alt="image-20210416150509922" style="zoom:50%;" />

### 遍历二叉树

Essence：把节点排成线性序列，使得每个节点有且仅有一个直接前驱和直接后继。

先左后右：**先序：**考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)

**中序：**考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)

**后序：**考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)

算法：1.递归

2.非递归  用栈存储

DLR先序遍历 （1）访问根结点；（2）先序遍历左子树；（3）先序遍历右子树。

LDR中序遍历 （1）中序遍历左子树；（2）访问根结点；（3）中序遍历右子树

 LRD后根遍历

### 树转换二叉树(一一对应关系)

1.兄弟间加线    2。对每个节点去掉它与孩子连线  3. 顺时针转45°

### 赫夫曼树 最优

最优二叉树   WPL = ΣW*l<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210423140217270.png" alt="image-20210423140217270" style="zoom: 50%;" />

构造huffman树：  在𝐹中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。赫夫曼树中没有度为1的结点。若叶子结点的个数为n，则赫夫曼树的结点总数为2n-1

**赫夫曼编码**是不等长编码赫夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀



<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210605160138226.png" alt="image-20210605160138226" style="zoom:33%;" />求（赫夫曼）编码时需要走一条从叶子结点到根结点的路径,译（解）码时需要走一条从根结点到叶子结点的路径。所以既需要知道双亲的信息又需要知道孩子的信息,故采用带双亲的孩子链表

### 计算树的深度

**深度优先遍历**（DFS递归实现）、广度优先遍历（BFS，层次遍历）二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。

​    2） 深度优先遍历：对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历、中序遍历、后序遍历。具体说明如下：

- 先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。
- 中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。
- 后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。

​    广度优先遍历：又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　　　

   3）深度优先搜素算法：不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。

​     广度优先搜索算法：保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。

### 非/线性结构

非线性结构，数学用语，其逻辑特征是一个结点元素可能有多个直接前趋和多个直接后继。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)。

传统文本（例如书籍中的文章和计算机的文本文件）都是线性结构，阅读是需要注意顺序阅读，而超文本则是一个非线性结构。在制作文本时，可将写作素材按内部联系划分成不同关系的单元，然后用制作工具将其组成一个网型结构。阅读时，不必按线性方式顺序往下读，而是有选择的阅读自己感兴趣的部分。

在超文本文件中，可以用一些单词，短语或图像作为连接点。这些连接点通常同其他颜色显示或加下划线来区分，这些形式的文件就成为超文本文件。通过非线性结构，可能实现页面任意跳转。

有一个以上根结点的数据结构一定是非线性结构。

## 图G=(v,w）

### 概念

图（Graph）是一种较线性表和树更为复杂的数据结构。图中任意两个数据元素之间都可能相关

graph = (顶点，顶点关系集)

弧（Arc）：若<v,w>∈VR，则<v,w>表示从v到w的一条弧。弧尾（Tail）：v称为弧尾（或初始点）。弧头（Head）：w称为弧头（或终端点）。

有向图（Digraph）：若<v,w>∈VR，但并不总有<w,v>∈VR，即VR是有序的。

无向图（Undigraph）：若<v,w>∈VR，必有<w,v>∈VR，即VR是对称的。<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210507131353868.png" alt="image-20210507131353868" style="zoom:33%;" />

一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。

**生成树**是对应连通图来说，而生成森林是对应非连通图来说的。如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，则一定有环，但有n-1条边的图不一定是生成树。

一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。

生成森林：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

### 储存方式

#### 1.数组（邻接矩阵）

O(n^2)

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210507132031429.png" alt="image-20210507132031429" style="zoom:50%;" />

#### 2.邻接表  

 O(n+e)

在无向图的邻接链表中，顶点vi的度恰为第i个链表中的结点数；而在有向图中，第i个链表中的结点个数只是顶点vi的出度，为求入度，必须遍历整个邻接表。因此，对于有向图，为了便于确定顶点的入度或以顶点为头的弧，可以建立一个有向图的逆邻接表(Inverse Adjacency List)                      ——按顶点入度建立

3.十字链表

十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来。十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。       ——按顶点入度和出度建立

4.邻接多重表

邻接多重表(AdjacencyMultilist)是无向图的另一种链式存储结构。与十字链表类似，在邻接多重表中，每一条边用一个结点表示，每一个顶点也用一个结点表示

### 关键问题

- [拓扑排序](https://zh.wikipedia.org/wiki/拓扑排序)算法(TSA)
- [关键路径](https://zh.wikipedia.org/wiki/关键路径)算法(CPA)
- [广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)算法(BFS)
- [深度优先搜索](https://zh.wikipedia.org/wiki/深度优先搜索)算法(DFS)

### 图的遍历

#### ·深度优先搜索

(树的先根遍历的推广) 递归

#### ·广度优先搜索

(树的按层次遍历的推广)

#### 连通性问题

非连通图的生成森林

### 最小代价生成树 MST



**MST性质**

设N=(V,{E})是一个连通的网络，U是顶点集V的非空子集。若(a,b)是一条具有最小权值（代价）的边，其中a∈U，b∈V-U，则必存在一棵包含边(a,b)的最小生成树。

**判断稀疏图与稠密图**
        这个判断方式没有绝对的标准，可以依据定义来判断，比如边的条数|E|很接近|V|²，那么毫无疑问是个稠密图，但是写算法时经常要根据数据的特点选择使用邻接矩阵还是邻接表，所以我们可以从使用算法的复杂度出发，比如对于Dijkstra算法，朴素Dijkstra时间复杂度是n²，而堆优化Dijkstra时间复杂度mlogn，其中m是边的个数，所以单从算法效率上讲，稀疏图与稠密图的分界点大概就在m=n²/logn处，但是实际上复杂度是有系数的，所以单从式子上计算也是不太科学的，可以作为一个参考。

##### **prim算法    **

**复杂度O(n^2) 适用于疏密图**.将图中顶点分为两个集合，其中集合X 包含图的一个顶点v0，集合Y 包含除v0 外的其它所有顶点；2、将跨接这两个集合的权值最小的边加入图中，并将其依附在集合Y 中的顶点v1 从Y 中移入集合X 中；3、反复执行过程2，直到集合Y 为空，所得到的生成子图即为最小生成树<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20211105134255698.png" alt="image-20211105134255698" style="zoom:50%;" />

**加点法**

##### **kruskal算法  **

复杂度O(eloge) 稀疏图.将图中所有边按权值从小到大排序；2、取权值最小的边，加入图中，判断是否形成了回路，若无，则保留此边，否则舍去此边而选择下一条代价最小的边；3、反复执行过程2，直到全部顶点均连通为止。<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20211105134323185.png" alt="image-20211105134323185" style="zoom:50%;" />

加边法

1、将图中所有边按权值从小到大排序；2、取权值最小的边，加入图中，判断是否形成了回路，若无，则保留此边，否则舍去此边而选择下一条代价最小的边；3、反复执行过程2，直到全部顶点均连通为止

**区别最短路径**   

最小生成树能够保证首先是树（对于n个顶点的图只有n-1条边），其次保证任意两个顶点之间都可达，再次保证这棵树的边权值之和为最小，但不能保证任意两点之间是最短路径；最短路径保证从源点S到目地点D的路径最小（有向图中不要求终点能到起点），不保证任意两个顶点都可达;

 一个图如果有负权环...路径长可以无穷小 ,因为可以不断的走这个环降低权值，而最小生成树是有限的，它不是你怎么走的问题，而是生成一个两两都可达的最小权值和的树的问题。

最小生成树是用最小代价遍历整个图中所有顶点，所有的权值和最小。而最短路径只是保证出发点到终点的路径和最小，不一定要经过所有顶点；

最小生成树是到一群点（所有点）的路径代价和最小，是一个n-1条边的树，最短路径是从一个点到另一个点的最短路径； 



### 有向无环图DAG

**工程能否顺利进行——**

#### **拓扑排序   偏序→全序**

**AOV网   用顶点表示活动，用弧表示活动之间的优先关系**

拓扑排序由某个集合上的一个偏序(图中不存在环路，部分成员可比较)得到该集合上的一个全序（全员可比较）的操作称为拓扑排序

如何进行拓扑排序？

(1)在有向图中选取一个没有前驱的顶点并输出它。(2)从图中删除该顶点和所有以它为尾的弧。重复上述两个步骤，直至全部顶点均已输出或当前图中不存在无前驱的顶点为止。若图中全部顶点均已输出，则图中不存在环；若当前图中不存在无前驱的顶点，则图中存在环

**估计完成整个工程所须的最短时间——**

#### **关键路径**

AOE-网(ActivityOnEdge)即边表示活动的网。它是一个带权的有向无环图。**顶点表示事件，弧表示活动，权值表示活动持续的时间。**

关键路径:从源点到汇点的最长路径(关键路径长度=最短工期)· 

关键活动:关键路径上的活动(关键活动的加快可以缩短工期)<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210507152429997.png" alt="image-20210507152429997" style="zoom:33%;" />

### 最短路径

问题抽象：用顶点表示城市，边表示城市之间的交通联系，边上的权值表示两个城市间的距离，从图中找到一条从代表城市A的顶点到代表城市B的顶点的路径，且路径上边的权值之和最小。这一问题就是图的最短路径问题。本节将讨论带权有向图（可以扩展到无向图），并称路径上的第一个顶点为源点（Source），最后一个顶点为终点（Destination）。

[两种最常见的最短路径问题]从某个源点到其余各顶点的最短路径（单源最短路径）每一对顶点间的最短路径

#### Dijkstra算法

condition：any 路径>0  & 单源 已知出发点

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210507203217843.png" alt="image-20210507203217843" style="zoom: 50%;" />临近，标记！

直到全部点标记结束，回溯找出路径

​		O(n^2) 堆优化->O(nlogn)

​    (贪婪算法)绿色为标记<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210508101200590.png" alt="image-20210508101200590" style="zoom:50%;" />👈链表储存的信息





#### Floyd算法

这个算法是一种基于**动态规划**的**多源最短路**算法。可解－节点。算法十分简洁优雅，代码如下：

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210508001955218.png" alt="image-20210508001955218" style="zoom:50%;" />



**本质：判断任意两点间的最短距离是否通过k节点**                     O(n^3)

理论依据：分类：1.若某节点处于起点到终点的最短路径上：a顶点到b顶点之间的最短距离可以查找是否有c顶点使距离缩小。

2.若某节点不处于最短路径上： 解**动态规划**题目的重点就是合理的**定义状态，划分阶段，**我们定义 f[k][i][j]为经过前k的节点，从i到j所能得到的最短路径，f[k][i][j]可以从f[k-1][i][j]转移过来，即不经过第k个节点，也可以从f[k-1][i][k]+f[k-1][k][j]转移过来，即经过第k个节点。观察一下这个状态的定义，满足不满足最优子结构和无后效性原则。



最优子结构：图结构中一个显而易见的定理：**最短路径的子路径仍然是最短路径** ,这个定理显而易见，比如一条从a到e的最短路a->b->c->d->e 那么 a->b->c 一定是a到c的最短路c->d->e一定是c到e的最短路，反过来，如果说一条最短路必须要经过点k，那么i->k的最短路加上k->j的最短路一定是i->j 经过k的最短路，因此，最优子结构可以保证。

condition：求任意两个节点间的最小路径

## 查找

ASL平均查找长度                                 动态查找表在查找的过程中同时插入不存在的记录，或删除某个已存在的记录。

#### 静态树表查找

1 最优查找树 时间开销大；

2 **次优查找树**：使左子树的权重之和与右子树的权重之和的差的绝对值尽量小。

1）判断当前节点指针是否为空，如果为空，则返回空指针；

2）否则，将当前节点的关键字key与K比较，若K=key，则返回当前节点的指针；若K>key，将其右孩子作为当前节点，转1）；若K<key，将其左孩子作为当前节点，

#### 索引顺序表的查找

（分块查找）

### 二叉排序树和平衡二叉树

BST二叉搜索树（排序树），若它的左子树不空，则左子树上所有的结点的值均不大于它根结点的值；　　若它的左子树不空，则左子树上所有的结点的值均不小于它根结点的值；　　

它的左右子树也是二叉搜索树，那么在查找x时，若x比根节点小可以排除右子树所有元素，去左子树中查找（类似二分查找），这样查找的效率非常好，而且插入的时间复杂度为O（h），h为树的高度，较O（n）来说效率提高不少。

故二叉搜索树用作一些查找和插入使用比较高的场景。

查找成功时的平均查找长度：

**ASL=∑（本层高度\*本层元素结点个数）/结点总数	**



平衡二叉树（Balanced Binary Tree) 又称AVL树，它具有如下性质：或者为空树，或者根节点的左、右子树也均为平衡二叉树，且左、右子树的树高之差的绝对值不超过1。平衡因子BF（balance factor）：节点的左子树高度减去右子树高度的值称为该节点的平衡因子。平衡二叉树上所有节点的平衡因子只可能是-1,0和1。平衡二叉树不平衡的二叉树

### 哈希表

**思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，理想状态不经过比较，一次存取就能得到所查元素。**

构造方法：直接定址法：

H(key)=key 或H(key)=a *key + b， a、b are constants

数字分析法

除留余数法:H(key) = key MOD p (p <m)

随机数法:选择一个随机函数，取关键字的随机函数值为哈希地址H(key) = random(key)

#### 冲突 

##### 开放定址法

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210610141716755.png" alt="image-20210610141716755" style="zoom:50%;" />



#### 求平均查找长度<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210610145416530.png" alt="image-20210610145416530" style="zoom:50%;" />

​					线性探测👆





## 内部排序

稳定排序：设序列中任意两个记录的关键字值相同，即Ki=Kj(i != j)，若排序之前记录Ri领先于记录Rj，排序后这种关系不变。

[根据排序时文件记录的存放位置]

内部排序：排序过程中将全部记录放在内存中处理。          外部排序：排序过程中需在内外存之间交换信息。大数据集来说，内存是远远不够的，这时候就涉及到外排序的知识了。　eg。多路归并排序



**插入排序：**<img src="https://pic3.zhimg.com/v2-8a97a82ab39183f3177e99b5bb74e55e_b.webp" alt="img" style="zoom:50%;" />

**希尔排序：**希尔排序有时又叫做 “缩小间隔排序”，它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序，从而实现对插入排序性能的改进。划分子列的特定方法是希尔排序的关键。我们并不是将原始列表分成含有连续元素的子列，而是确定一个划分列表的增量 “i”，这个i更准确地说，是划分的间隔。然后把每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序，最后当 i=1 时，对整体进行一次直接插入排序。<img src="https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.webp" alt="img" style="zoom:50%;" />

**直接插入排序在待排序列的关键字基本有序时，效率较高；在待排序的记录个数较少时，效率较高**

如何选择最佳的增量序列，目前尚未解决，但需注意：最后一个增量值必须为1；避免增量序列中的值（尤其是相邻的值）有公因子。实验结果：当n在某个特定的范围内，希尔排序所需的比较和移动的次数约为n^1.3，当n趋近于无穷时，可减少到
$$
n(logn)^2
$$




**选择排序**：

1）简单选择排序；2）树形选择排序；3）堆排序



#### 快排

快速排序是目前被认为在所有同数量级(O(nlogn))的排序算法中平均性能好的

快排（三数中值）思想：***在无序数组中找到分区点 ，左边都为小于等于分区点的值，右边都为大于等于分区点的值。将整个数组分成 N 个这样的数组，当最后分区小于三个元素时说明排序完成。\***

快速排序的算法好坏很大程度上取决于 『 分区点 』，三者取中或随机产生，即取数组最左端最右端以及数组中间三个数的中间数为分区点，减少采用左右端点碰到极端顺序的出现的最坏情况（ 当选取左右端点，碰到数据有序，从大到小或是从小到大的情况 ，算法时间复杂度就会变成最坏时间复杂度）。

**归并排序**

指将两个或两个以上的有序表组合成一个新的有序表的操作，将待排序列R[1..n]看作n个长度为1的有序子序列，两两归并，得到n/2个长度为2的有序子序列(或最后一个子序列长度为1)

**基数排序**

为实现多关键字排序，通常有两种方法：1）最高位优先法(MSD法):先对最主位关键字𝐾0排序，将序列分成若干子序列，然后分别就每个子序列对关键字𝐾1排序。依次重复，直至对关键字𝐾d−1排序，最后将所有子序列依次联接成一个有序序列。2）最低位优先法（LSD法）

**SumUp**

<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20210530132725369.png" alt="image-20210530132725369" style="zoom:33%;" /

快速排序的平均时间最短，但快速排序在最坏情况下，时间性能不如堆排序和归并排序。在n较大时，归并排序所需时间较堆排序更省，但它所需的辅助存储量更多。当n较小时如(n<50)，可采用直接插入排序。直接插入排序常与其他排序算法结合使用。

当n较大时，应采用时间复杂度为O(nlogn)的排序算法(主要为快速排序和堆排序)或者基数排序。其中基数排序最适用于n很大而关键字较小的序列。

<img src="C:\Users\Stan\Pictures\Saved Pictures\屏幕截图 2021-06-10 155440.png" alt="屏幕截图 2021-06-10 155440" style="zoom: 50%;" />



# 问题

1.内存访问错误造成Segmentation fault （SIGSEGV）

　* 内存分配未成功，却使用了它。

　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行

　　检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。

　　* 内存分配虽然成功，但是尚未初始化就引用它。

　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

　　* 内存分配成功并且已经初始化，但操作越过了内存的边界。

　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。

　　* 忘记了释放内存，造成内存泄露。

　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。

　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。

  * 释放了内存却继续使用它。　　

    * 【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

  　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

  　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

  　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。

  　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。







# Algorithm

## 5大基本算法：

#### 贪心算法：



#### 分治法（递归）

适用情况：

1） 该问题的规模缩小到一定的程度就可以容易地解决

2） 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3） 利用该问题分解出的子问题的解可以合并为该问题的解；

4） 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；

第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。

第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

复杂性：T（n）= k T（n/m）+f（n）

#### 动态规划

**适用的情况**

能采用动态规划求解的问题的一般要具有3个性质：

（1） **最优化原理**：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

（2） 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<img src="C:\Users\Stan\AppData\Roaming\Typora\typora-user-images\image-20211029132522785.png" alt="image-20211029132522785" style="zoom:50%;" />

#### 回溯

#### 穷举enum



## properties

1. 有穷性（Finiteness）。算法的有穷性是指算法必须能在执行有限个步骤之后终止；
2. 确切性(Definiteness)。算法的每一步骤必须有确切的定义；
3. 输入项(Input)。一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
4. 输出项(Output)。一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
5. 可行性(Effectiveness)。算法中的操作都可以通过已经实现的基本运算执行有限次来实现。

